package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.37

import (
	"context"
	"fmt"
	"practice/graph/model"
	"strconv"
)

// UpsertPlayer is the resolver for the upsertPlayer field.
func (r *mutationResolver) UpsertPlayer(ctx context.Context, input model.PlayerInput) (*model.UpsertPlayerResponse, error) {
	var response model.UpsertPlayerResponse

	id := input.ID
	var player model.Player
	player.Name = input.Name
	player.Nationality = input.Nationality
	player.Position = input.Position
	team := r.GetTeamByName(input.TeamName)

	n := len(r.Resolver.PlayerStore)
	if n == 0 {
		r.Resolver.PlayerStore = make(map[string]model.Player)
	}

	if id != nil {
		ps, ok := r.Resolver.PlayerStore[*id]
		if !ok {
			response.Code = 403
			response.Success = false
			response.Message = "Player not found"
			return &response, fmt.Errorf("Player not found")

		}
		// Found Player
		if input.Goals != nil {
			player.Goals = input.Goals
		} else {
			player.Goals = ps.Goals
		}
		if input.Assists != nil {
			player.Assists = input.Assists
		} else {
			player.Assists = ps.Assists
		}
		//Extract to Helper method
		if team != nil {
			player.Team = team
		}
		response.Message = "Player updated"
		r.Resolver.PlayerStore[*id] = player
		// Creating a New Player
	} else {
		//generate unique id
		nid := strconv.Itoa(n + 1)
		player.ID = nid
		if input.Goals != nil {
			player.Goals = input.Goals
		}
		if input.Assists != nil {
			player.Assists = input.Assists
		}
		//Extract to Helper method
		if team != nil {
			player.Team = team
		}
		r.Resolver.PlayerStore[nid] = player
		response.Message = "Player Created"
	}

	return &model.UpsertPlayerResponse{
		Player:  &player,
		Code:    200,
		Success: true,
		Message: response.Message,
	}, nil
}

// SeedTeams is the resolver for the seedTeams field.
func (r *mutationResolver) SeedTeams(ctx context.Context, input *bool) ([]*model.Team, error) {
	seededTeams := make([]*model.Team, 0)
	n := len(r.Resolver.TeamStore)
	if n == 0 {
		r.Resolver.TeamStore = make(map[string]model.Team)
	}
	teams := []model.TeamName{
		"MANCHESTERUNITED",
		"ARSENAL",
		"CHELSEA",
		"MANCHESTERCITY",
		"WESTHAM",
		"WOLVERHAMPTONWANDERERS",
		"SPUDS",
		"NEWCASTLEUNITED",
		"BRENTFORD",
		"LUTONTOWN",
		"BURNLEY",
		"NOTTINGHAMFOREST",
		"BRIGHTON",
		"FULHAM",
		"FREEAGENT"}

	for i, t := range teams {
		index := strconv.Itoa(i)
		var team model.Team
		team = (MakeTeam(t, index))
		r.Resolver.TeamStore[index] = team
		seededTeams = append(seededTeams, &team)
	}

	return seededTeams, nil
}

// Teams is the resolver for the teams field.
func (r *queryResolver) Teams(ctx context.Context) ([]*model.Team, error) {
	teams := make([]*model.Team, 0)

	//iteration through MAP is not working as planned result only returns 1 team name 6 times.
	for idx := range r.Resolver.TeamStore {
		team := r.Resolver.TeamStore[idx]
		teams = append(teams, &team)
	}
	return teams, nil
}

// Players is the resolver for the players field.
func (r *queryResolver) Players(ctx context.Context, position *model.Position) ([]*model.Player, error) {
	players := make([]*model.Player, 0)

	for idx := range r.Resolver.PlayerStore {
		player := r.Resolver.PlayerStore[idx]
		if player.Position == *position {
			players = append(players, &player)
		}
	}

	return players, nil
}

// Player is the resolver for the player field.
func (r *queryResolver) Player(ctx context.Context, id string) (*model.Player, error) {
	player, ok := r.Resolver.PlayerStore[id]
	if !ok {
		return nil, fmt.Errorf("not found")
	}
	return &player, nil
}

// Team is the resolver for the team field.
func (r *queryResolver) Team(ctx context.Context, id string) (*model.Team, error) {
	team, ok := r.Resolver.TeamStore[id]
	if !ok {
		return nil, fmt.Errorf("not found")
	}
	return &team, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func MakeTeam(name model.TeamName, id string) model.Team {

	var team model.Team
	players := make([]*model.Player, 0)
	team.Name = name
	team.League = "English Premier League"
	team.ID = id
	team.Players = players

	return team
}
func (r *Resolver) GetTeamByName(name model.TeamName) *model.Team {
	fmt.Println("Getting team %s by name...", name)
	for _, t := range r.TeamStore {
		if t.Name == name {
			fmt.Println("And we found them!")
			return &t
		}
	}
	return nil
}
func (r *mutationResolver) AddGoals(ctx context.Context, id string, goals *int) (*model.UpsertPlayerResponse, error) {
	panic(fmt.Errorf("not implemented: AddGoals - addGoals"))
}
